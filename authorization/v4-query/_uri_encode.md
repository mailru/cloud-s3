#### Данная функция
- принимает в качестве аргументов
```
строка
```
возвращает
```
строка
```
#### В данной функции вы должны
- заэнкодить все символы которые не являются unreserved
     - включение и выключение слеша из этого списка обусловлено необходимостью энкодить и урлы и обычные параметры
```
A-Za-z0-9._~-
```
```
A-Za-z0-9._~/-
```
 
- заменить все плюсы на %20
- после энкодинга необходимо прогнать полученную строку через функцию (_canonicalize) которая выполнит следующее:
  - идет по строке
    - если встречается %.. то разъенкоживает символ а затем если он не unreserved то энкодят его снова
    - если встречается простой символ то оставляем его как есть а затем если он не unreserved то энкодим его
    - (данная функция обеспечивает абсолютно правильный энкодинг вне зависимости от пришедших параметров)

#### Прилагается пример данной функции на языке perl
```
our %UNRESERVED = map { $_ => 1 } 'a'..'z','A'..'Z','0'..'9',qw(- . _ ~ /);

sub _canonicalize {
	my ($uri) = @_;
	$uri =~ s/\+/%20/g;
	$uri =~ s{\G%(..)|(.)}{
	    my $c = $1 ? chr(hex($1)) : $2;
	    $UNRESERVED{$c} ? $c : sprintf "%%%02X", ord($c)
	}ge;
	return $uri;
}

sub _uri_encode {
	my ($uri, $encode_slash) = @_;
	my $unreserved_string = $encode_slash ? "A-Za-z0-9._~-" : "A-Za-z0-9._~/-";
	$uri =~ s{([^$unreserved_string])}{ sprintf '%%%02X',ord($1) }sge;
	$uri =~ s/\+/%20/g;
	$uri = _canonicalize($uri, $encode_slash);
	return $uri;
}
```
